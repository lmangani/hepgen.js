#!/usr/bin/env node

/* PCAP TEXT to HEPGEN Convertor */
/* Modules import */

const fs = require('fs')
const args = process.argv.slice(2)
const parSIP = require('parsip')
const debug = true

if (!args || !args[0]) {
  if (debug)console.log('{}')
  process.exit(1)
}

/* when converting pcaps, we are only interested in the time difference
    between messages, as we will use them for 'sleeping'
    */
const cache = { previous: { time: 0 } } // set this to 0
const netRegex = /([A-Z]+) ([0-9]+-[0-9]+-[0-9]+)T[0-9]+:[0-9]+:([0-9]+).([0-9]+)(.*)\s([0-9]+.[0-9]+.[0-9]+.[0-9]+):([0-9]+)(.*)\s([0-9]+.[0-9]+.[0-9]+.[0-9]+):([0-9]+)/i
const callids = []

if (debug)console.log('Reading SIP from file: ', args[0])

/* Moved to Async Sugar */

const fileContent = new Promise((resolve, reject) => {
  // promisify readFile
  fs.readFile(args[0], 'utf8', (err, contents) => {
    if (debug)console.log('read file about to resolve', err, contents.length)
    if (err) {
      reject(err)
      return
    }

    if (contents) {
      if (debug)console.log('resolving content')
      resolve(contents)
    }
  })
})

fileContent.then(handleContent).catch(handleError)

async function handleContent (contents) {
  if (debug)console.log('handler Content called -----------------')
  const parsed = contents.split('proto:')
  parsed.shift()
  // console.log('parsed array of promises?', parsed, parsed.length);

  const messages = []

  for (const key in parsed) {
    try {
      const msg = await handleRow(parsed[key], key)
      messages.push(msg)
    } catch (err) {
      console.log('caught in promise', err)
    }
  }

  const config = {
    NAME: 'HEPGEN ' + args[0],
    HEP_SERVER: '127.0.0.1',
    HEP_PORT: 9060,
    HEP_ID: '2001',
    HEP_AUTH: 'myHep',
    // the Messages to send
    MESSAGES: messages
  }

  let output = '/* HEPGEN Autogenerated from file => ' + args[0] + ' */\r\n'
  output += 'var config = { \r\n'
  for (const key of Object.keys(config)) {
    console.log(key, key !== 'MESSAGES')
    if (key !== 'MESSAGES') {
      if (typeof config[key] === 'string') {
        output += ' ' + key + ':' + '"' + config[key] + '",\r\n'
      } else {
        output += ' ' + key + ':' + config[key] + ',\r\n'
      }
    }
  }
  output += ' MESSAGES: [ \r\n'
  for (const item of config.MESSAGES) {
    output += '    '
    output += item
    output += ',\r\n'
  }
  output += ' ]\r\n};\r\n'
  output += 'module.exports = config;'
  if (debug)console.log('writing to file', output)
  fs.writeFile(args[1], output, console.log)
}

function handleError (err) {
  throw err
}

/* function to handle each SIP Row / Message */

async function handleRow (row, key) {
  if (debug)console.log('handling row', row, key)
  return new Promise(function (resolve, reject) {
    if (debug)console.log('IN PROMISE', key)
    let detectedEOL = '\r\n'
    const detect = row.split(/[0-9]\n|[a-z]\n/)
    if (detect.length > 1) { detectedEOL = '\n' }
    if (debug)console.log('detected following EOL in file', JSON.stringify(detectedEOL))
    const tmp = row.split(/---> [0-9]+.[0-9]+.[0-9]+.[0-9]+:[0-9]+\r\n\r\n|---> [0-9]+.[0-9]+.[0-9]+.[0-9]+:[0-9]+\n\n/)
    if (debug)console.log('temp', tmp, row, !tmp[1] || !row)
    if (!tmp[1] || !row) {
      if (debug)console.log('stopped it', !tmp[1], !row)
      reject(new Error('error with row parsing'))
      return
    } else {
      if (debug)console.log('parsing')
      var rawSIP = tmp[1].split(detectedEOL).join('\r\n')
      const mSIP = parSIP.getSIP(rawSIP)
      // console.log(mSIP, '-----------------');

      // Replace Session Identifiers need to be unique
      if (mSIP) {
        if (mSIP.call_id) {
          if (!callids[mSIP.call_id]) { callids[mSIP.call_id] = Math.random().toString(36).substring(8) + mSIP.call_id }
          if (debug)console.log('replacing call_id', mSIP.call_id, callids[mSIP.call_id])
          rawSIP = rawSIP.split(mSIP.call_id).join(callids[mSIP.call_id])
        };
        if (mSIP.via_branch) {
          if (!callids[mSIP.via_branch]) { callids[mSIP.via_branch] = Math.random().toString(36).substring(8) + mSIP.via_branch }
          if (debug)console.log('replacing via_branch', mSIP.via_branch, callids[mSIP.via_branch])
          rawSIP = rawSIP.split(mSIP.via_branch).join(callids[mSIP.via_branch])
        };
        if (mSIP.from_tag) {
          if (!callids[mSIP.from_tag]) { callids[mSIP.from_tag] = Math.random().toString(36).substring(8) + mSIP.from_tag }
          if (debug)console.log('replacing from_tag', mSIP.from_tag, callids[mSIP.from_tag])
          rawSIP = rawSIP.split(mSIP.from_tag).join(callids[mSIP.from_tag])
        };
        if (mSIP.to_tag) {
          if (!callids[mSIP.to_tag]) { callids[mSIP.to_tag] = Math.random().toString(36).substring(8) + mSIP.to_tag }
          if (debug)console.log('replacing to_tag', mSIP.to_tag, callids[mSIP.to_tag])
          rawSIP = rawSIP.split(mSIP.to_tag).join(callids[mSIP.to_tag])
        };
      }
    }
    // create message block for configuration
    if (debug)console.log('making a block from ', tmp[0])


    let block = row.replace(netRegex, function (match, proto, date, time, timeMicro, unused, fromIp, fromPort, divide, toIp, toPort) {
      if(debug) console.log('args for replace time', arguments)
      time = parseInt(time) // in seconds
      timeMicro = parseInt(timeMicro) // in microseconds
      if (debug)console.log('TEST', time, timeMicro, cache.previous.time)
      fromPort = parseInt(fromPort); toPort = parseInt(toPort)
      const timePresent = addMicroSeconds(timeMicro, time)
      const pauseTime = parseFloat(parseFloat(timePresent - cache.previous.time).toFixed(9)) || 0
      if (debug) console.log(`Pause Time on key ${key} is ${pauseTime}, based on ${parseFloat(parseFloat(timePresent - cache.previous.time).toFixed(9))}`)
      const block = {
        rcinfo: {
          type: 'HEP',
          version: 3,
          payload_type: 1,
          captureId: '2001',
          capturePass: 'myHep',
          ip_family: 2,
          protocol: proto === 'UDP' ? 17 : 6,
          proto_type: 1,
          srcIp: fromIp,
          dstIp: toIp,
          srcPort: fromPort,
          dstPort: toPort
        },
        pause: pauseTime,
        payload: JSON.stringify(rawSIP || tmp[1])
      }
      if (debug)console.log('time before: ', time)
      cache.previous = { time: timePresent }
      let string = '{\r\n'
      for (const key of Object.keys(block)) {
        if (key === 'rcinfo') {
          string += '     rcinfo:{ \r\n'
          for (const item2 of Object.keys(block.rcinfo)) {
            string += '       ' + item2 + ':'
            if (typeof block.rcinfo[item2] === 'string') {
              string += '"' + block.rcinfo[item2] + '",\r\n'
            } else {
              string += block.rcinfo[item2] + ',\r\n'
            }
          }
          string += '     },\r\n'
          continue
        } else {
          string += '     ' + key + ':' + block[key] + ',\r\n'
        }
      }
      string += 'XXX'
      return string
    })
    block = block.split('XXX')[0]
    block += '    }'
    if (debug)console.log('resolving', block)
    resolve(block)
  })
}

/* time utility
    returns total time in seconds as a float to allow pause math
    */
function addMicroSeconds (micro, sec) {
  var milliSec = sec * 1000
  var milliMicro = micro / 1000
  var total = milliSec + milliMicro
  return parseFloat(total/1000).toFixed(9)
}
